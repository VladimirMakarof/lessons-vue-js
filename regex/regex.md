**Регулярные выражения** - шаблоны используемые для сопоставления последовательностей символов в строках

_в JS регулярные выражения - это объекты RegExp_

**Методы test и exec**

**Методы строк, которые работают с регулярными выражениями:
match, replace, search, split**

способы создать регулярное выражение:

1. let reg = /регулярное выражение/
   Флаги, после последнего /
   i - регистронезависимый поиск
   g - глобальный поиск по всей строке
2. reg = new RegEx('Регулярное выражение')

console.log(reg.text("строка")); -если найдет регулярное выражение то вернёт true если нет то false
console.log(teg.exec("строка")) - массив с более подробная информация по наиденную совпадению либо null

регулярное выражение без флагов являются регистрозависемые и читаются слева на право.

можно использовать символы при использование регулярных выражениях.

^ начало строки
reg = /^дом/ - начинаться строка должна со слова дом

$ конец строки
reg = /дом$/ - заканчивается строка на слово дом

[] - перечисляем любую последовательность символов
reg = /[ои]/i - значит что строка должна содержать любой символ из набора в квадратных скобках
reg = /к[ои]/i после буквы к должно быть либо о либо и

любой символ от а до я, любой символ от А до Я, Ёё
reg = / 626 [а-яА-ЯЁё]/;

любое число от 0 и до 9
reg = /[0-9]/

[^символы] любой символ кроме перечисленных в []
reg = /[^0-9]/

\w - означает буквы цифры и знаки подчёркивания в единственном числе
reg = /дом \w$/;

\W большая W все кроме букв, цифр и знаков подчёркивания
\s - пробел
\S - все кроме пробела
\d - цифры [0-9]
\D - все кроме цифр - [^0-9]
\b - границы слова
\B - не границы слова

Регулярное выражение на JavaScript, которое проверяет, соответствует ли строка формату цвета в шестнадцатеричной нотации с символом #

`reg = /^#([0-9a-fA-F]{6}|[0-9a-fA-F]{3})$/`
_Это выражение проверяет, что строка начинается с символа #, за которым следует шестизначное или трехзначное значение в шестнадцатеричной системе. Квадратные скобки и вертикальная черта указывают на то, что выражение соответствует либо шестизначному, либо трехзначному формату цвета. Символы `[0-9a-fA-F]` указывают на диапазон символов, допустимых в шестнадцатеричной системе (цифры от 0 до 9 и буквы a-f и A-F, обозначающие числа от 10 до 15). Квантификатор {6} указывает на то, что перед ним должно быть ровно 6 символов, а {3} - ровно 3 символа._

_Таким образом, регулярное выражение проверяет, что строка начинается с символа #, за которым следует либо 6 символов в диапазоне от 0 до 9 и a-f/A-F, либо 3 символа в том же диапазоне. Если строка соответствует этому формату, то регулярное выражение возвращает true, в противном случае - false._

**Квантификаторы** - это символы в регулярных выражениях, которые определяют количество повторений предшествующего элемента. По умолчанию работают в жадном режиме(будут продолжить поиск до конца строки) что бы остановить жадный поиск нужно ставить знак ? .
`reg = /<.*>/;`
символ{2} - символ повторяется 2 раза
`reg = /abc{2}/` -сколько раз должен повторятся последний символ
символ{2, } - символ повторяется от 2 раз
символ{2, 7} - символ повторяется от 2 и до 7
. - любой один символ

`* - предшествующий элемент должен встречаться ноль или более раз`
`reg = /abc*/`
`+ - предшествующий элемент должен встречаться один или более раз`
reg = /abc+/
`? - предшествующий элемент может встречаться ноль или один раз`
reg = /abc?/
`{n} - предшествующий элемент должен встречаться ровно n раз`
`{n,} - предшествующий элемент должен встречаться n или более раз`
`{n,m} - предшествующий элемент должен встречаться от n до m раз`

## Опережающие и ретроспективные проверки

**Позитивная опережающая проверка**

`A(?=B)` _- найти А, при условие что за А идёт В_

**Негативная опережающая проверка**

`A(?!B)` _- найти А, при условие что за А не идёт В_

let string = "Количество: 60 шт. Стоимость: 23$"

## задача на регулярное выражение js нужно любое число заменить на 30

Количество: 60 шт. Стоимость: 23$

`const regex = /\d+(?=\$)/; `\$ _- что бы воспринимался как символ а не конец строки_

`const text = 'Количество: 60 шт. Стоимость: 23$'; `

`const replacedText = text.replace(regex, '30');`

`console.log(replacedText);`

**Позитивная ретроспективная проверка**

`(?<=B)A ` _- найти A, при условии что перед ним идёт B_

`reg = /(? <= \$ | €)\d+/` - (|) знак или

**Негативная ретроспективная проверка**

`(? < !B)A` _- найти A, при условии, что перед ним не идёт B_
